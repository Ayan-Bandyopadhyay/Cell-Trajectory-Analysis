{
    "contents" : "unloadNamespace(\"flowcatchR\")\nlibrary(devtools)\ndev_mode(on=T)\nlibrary(BiocParallel)\nlibrary(flowcatchR)\n\n#dev.off()\n## FUNCTIONS\nkinematics1 <- function(trajectoryset,\n                        trajectoryIDs=NULL,\n                        acquisitionFrequency=30, # in milliseconds\n                        scala=50, # 1 pixel is ... micrometer\n                        feature=NULL)\n{\n  # first check whether the user wants to know what features are available to compute\n  if(!is.null(feature)) {\n    if (feature==\"?\") {\n      cat(\"Available features to compute are listed here below.\n          Please select one among delta.x, delta.t, delta.v, totalTime,\n          totalDistance, distStartToEnd, curvilinearVelocity,\n          straightLineVelocity, linearityForwardProgression, trajMSD,\n          velocityAutoCorr, instAngle, directChange or dirAutoCorr\")\n      return(NULL)\n    }\n  }\n  # compute all, for one or all trajectories\n  if(!is.null(trajectoryIDs)) # then operate on a single trajectory\n  {\n    \n    kineSet.out <- extractKinematics.traj(trajectoryset,trajectoryIDs,acquisitionFrequency=acquisitionFrequency,scala=scala) # returns a KinematicsFeatureSet object\n    # then eventually just report the desired kinematic feature\n    if(is.null(feature))\n    {\n      return(kineSet.out)\n    } else {\n      kineFeat.out <- kineSet.out[[feature]]\n      if(is.null(kineFeat.out)) stop(\"You selected a feature whose name is not available in the set (or was not computed because the trajectory was too short).\n                                     Please select one among delta.x, delta.t, delta.v, totalTime, totalDistance, distStartToEnd, curvilinearVelocity, straightLineVelocity, \n                                     linearityForwardProgression, trajMSD or velocityAutoCorr\")\n      return(kineFeat.out)\n    }\n    \n  } else { # it will be done on all trajectories of the trajectoryset\n    tmp <- list()\n    #dim(tmp) <- c(length(trajectoryset),)\n    for(i in 1:length(trajectoryset))\n    {\n      frameCount <- trajectoryset[[i]]$trajectory$frame\n      xCoords <- trajectoryset[[i]]$trajectory$xCoord\n      yCoords <- trajectoryset[[i]]$trajectory$yCoord\n      fx <- splinefun(frameCount, xCoords)\n      gx <- fx\n      environment(gx) <- new.env(parent=environment(fx))\n      z <- get(\"z\", envir=environment(fx)) \n      z$y <- z$b\n      z$b <- 2*z$c\n      z$c <- 3*z$d\n      z$d <- rep(0, z$n)\n      assign(\"z\", z, envir=environment(gx))\n      hx <- gx\n      environment(hx) <- new.env(parent=environment(gx))\n      z <- get(\"z\", envir=environment(gx)) \n      z$y <- z$b\n      z$b <- 2*z$c\n      z$c <- rep(0, z$n)\n      z$d <- rep(0, z$n)\n      assign(\"z\", z, envir=environment(hx))\n      \n      fy <- splinefun(frameCount, yCoords)\n      gy <- fy\n      environment(gy) <- new.env(parent=environment(fy))\n      z <- get(\"z\", envir=environment(fy)) \n      z$y <- z$b\n      z$b <- 2*z$c\n      z$c <- 3*z$d\n      z$d <- rep(0, z$n)\n      assign(\"z\", z, envir=environment(gy))\n      hy <- gy\n      environment(hy) <- new.env(parent=environment(gy))\n      z <- get(\"z\", envir=environment(gy)) \n      z$y <- z$b\n      z$b <- 2*z$c\n      z$c <- rep(0, z$n)\n      z$d <- rep(0, z$n)\n      assign(\"z\", z, envir=environment(hy))\n      kineOne <- c(Xposition = fx, Xvelocity = gx, Xacceleration = hx, Yposition = fy, Yvelocity = gy, Yacceleration = hy)\n      tmp[[i]] <- kineOne\n    }\n    # additional class attribute?\n    \n    kineSetList.out <- tmp\n    # then eventually just report the desired kinematic feature\n    if(is.null(feature))\n    {\n      return(kineSetList.out)\n    } else {\n      kineFeatList.out <- lapply(kineSetList.out,function(arg){arg[[feature]]})\n      if(all(unlist(lapply(kineFeatList.out,function(arg){is.null(arg)})))) stop(\"You selected a feature whose name is not available in the set (or was not computed because\n                                                                                 the trajectory was too short). Please select one among delta.x, delta.t, delta.v, totalTime,\n                                                                                 totalDistance, distStartToEnd, curvilinearVelocity, straightLineVelocity, \n                                                                                 linearityForwardProgression, trajMSD or velocityAutoCorr\")\n      if(feature %in% c(\"totalTime\",\"totalDistance\",\"distStartToEnd\",\"curvilinearVelocity\",\"straightLineVelocity\",\"linearityForwardProgression\"))\n      {\n        kineFeatList.out <- unlist(kineFeatList.out)\n      }\n      return(kineFeatList.out)\n    }\n  }\n}\n#greenThresh takes in rgb images, outputs a frames object in green channel\ngreenThresh <-function(images)\n{\n  # instance variables\n  frameCount = dim(cap)[4]\n  # rest of the function\n  newGreenFirst = c(matrix(nrow = 1388, ncol = 1040))\n  newRedFirst = c(matrix(nrow = 1388, ncol = 1040))\n  newBlueFirst = c(matrix(nrow = 1388, ncol = 1040))\n  #imgFirstVector = vector(length = 1388*1040)\n  threshedFrames = array(dim = c(1388,1040,frameCount))\n  for (i in 1:frameCount)\n  {\n    oldGreenFirst= c(cap[,,2,i])\n    oldBlueFirst = c(cap[,,3,i])\n    oldRedFirst =  c(cap[,,1,i])\n    createGreenImage <- function(oldGreen,oldRed,oldBlue) \n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldGreen=0\n      }\n      return(oldGreen)\n    }\n    createRedImage <- function(oldGreen,oldRed,oldBlue) \n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldRed=0\n      }\n      return(oldRed)\n    }\n    createBlueImage <- function(oldGreen,oldRed,oldBlue) \n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldBlue=0\n      }\n      return(oldBlue)\n    }\n    r <-mapply(createRedImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    g <-mapply(createGreenImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    b <-mapply(createBlueImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    r <- matrix(r,nrow = 1388, ncol = 1040)\n    g <- matrix(g,nrow = 1388, ncol = 1040)\n    b <- matrix(b,nrow = 1388, ncol = 1040)\n    imgfirstNew = rgbImage(red = r, green = g, blue = b)\n    image(1,1,matrix(1,nrow = 1,ncol = 1),col = rgb(red = imgfirstNew[596,507,1], green = imgfirstNew[596,507,2],blue = imgfirstNew[596,507,3] ))\n    r <- c(r)\n    g<- c(g)\n    b <- c(b)\n    hsvColor<-rgb2hsv(r = imgfirstNew[596,507,1], g= imgfirstNew[596,507,2],b= imgfirstNew[596,507,3], maxColorValue = 1)\n    image(1,1,matrix(1,nrow = 1,ncol = 1), col = hsv(h=hsvColor[1,1],s=hsvColor[2,1],v=hsvColor[3,1]))\n    # range is between h: 61/360 to 140/360, s: greater than 0, v: greater than 0\n    \n    hsvColors <- rgb2hsv(r=r,g=g,b=b)\n    \n    imgH <- hsvColors[1,]\n    imgS <- hsvColors[2,]\n    imgV <- hsvColors[3,]\n    grayscaleVector <- vector(length=1388*1040)\n    createBinaryVector <- function(grayVector,h,s,v)\n    {\n      \n      if (h>(61/360) && h<(140/360) && s>0.15)\n      {\n        grayVector = 1\n      }\n      else\n      {\n        grayVector = 0 \n      }\n      return(grayVector)\n    }\n    grayscaleVector <- mapply(createBinaryVector,grayVector=grayscaleVector,h=imgH,s=imgS,v=imgV)\n    binaryImage <- fillHull(as.Image(matrix(grayscaleVector, ncol = 1040,nrow = 1388)))\n    threshedFrames[,,i] <- binaryImage\n  }\n  rgbFrames = EBImage::channel(as.Image(threshedFrames),'rgb')\n  greenFrames = channel.Frames(rgbFrames, \"green\")\n  return(greenFrames)\n}\n\n# The rest:\n# PROCESSING\n\n# Read frames\nframeCount <-length(list.files(\"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\SingleCellTimeLapseFiles2\"))\nframeCount = frameCount\ncap <- read.Frames(image.files=\"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\SingleCellTimeLapseFiles2\", nframes=frameCount)\ndisplay(cap)\nprint(dim(cap)) \ncap = as.Image(cap)\n\n# USER INPUT FOR CAP TOP/BOT\nimgFirst = as.Image(cap[,,,1])\ndisplay(imgFirst, method=\"raster\")\nprint(\"Click on the bottom of the capillary\")\ncapBot = dim(imgFirst)[2] - as.integer(as.data.frame(locator(1))[1,2])\n# locator: top down, not bottom up\nprint(c(\"Bottom of capillary:\", capBot, \"pixels up\"))\nprint(\"Click on the top of the capillary\")\ncapTop = dim(imgFirst)[2] - as.integer(as.data.frame(locator(1))[1,2])\n\n# THRESHOLD FRAMES, disp 1st. binaryImg is a frames object in green channel\ncapGreen <- greenThresh(images = cap)\ndisplay(capGreen)\nimgFirst = as.Image(capGreen[,,1])\ndisplay(imgFirst)\n\n# USER INPUT FOR CELL DETECTION BOUNDS\ndisplay(imgFirst, method = \"raster\")\nabline(h=capTop, col=\"red\")\nabline(h=capBot, col=\"red\")\nprint(\"Click on the bottom bound for cell detection\")\ncellBot=  as.integer(as.data.frame(locator(1))[1,2])\nprint (\"Click on the top bound for cell detection\")\ncellTop=  as.integer(as.data.frame(locator(1))[1,2])\nprint(dim(imgFirst[2]))\nprint(capBot)\nprint(cellBot+1)\n\n# Create Trajectories\ncapNew = Frames(cap[,cellTop:cellBot,,], \"green\")\ntheFrame = capGreen[,cellTop:cellBot,]\ntheFrame <- EBImage::channel(as.Image(theFrame), 'rgb')\n#DELETE SMALL OBJECTS\ntheFrame2 <- Frames(theFrame, \"green\")\nsegmentedPlatelets <- array(dim = c(1388,dim(theFrame2)[2],dim(theFrame2)[3]))\nprint(dim(segmentedPlatelets))\nprint(dim(watershed(distmap(theFrame2), tolerance = 0.1, ext=1)))\nfor (i in 1:dim(theFrame2)[3]) {\n  segmentedPlatelets[,,i] <- watershed(distmap(theFrame2[,,i]), tolerance=0.1,ext=1)\n  segmentedPlatelets[,,i] <- fillHull(as.Image(segmentedPlatelets[,,i]))\n  newList=ifelse(computeFeatures.shape(segmentedPlatelets[,,i])[,'s.area'] <10, \"less than 10\" ,\"more than 10\")\n  newList1= which(newList %in% \"less than 10\")     #match(\"less than 10\", newList)\n  segmentedPlatelets[,,i] = rmObjects(segmentedPlatelets[,,i], newList1, reenumerate=TRUE)\n}\ndisplay(segmentedPlatelets)\ntheFrame2 <- EBImage::channel(as.Image(segmentedPlatelets), 'rgb')\ntheFrame2<- Frames(theFrame2, \"green\")\ndistmap_thre <- distmap(theFrame2)\npreprocessedPlatelets <- watershed(distmap_thre,tolerance=0.1,ext=1)\npreprocessedPlatelets <- fillHull(preprocessedPlatelets)\npreprocessedPlatelets <- EBImage::channel(as.Image(preprocessedPlatelets), 'rgb')\npreprocessedPlatelets <- Frames(preprocessedPlatelets, \"green\")\ndisplay(preprocessedPlatelets)\nplatelets <- particles(capNew, preprocessedPlatelets)\nprint(defaultPenalty)\nlinkedPlatelets <- link.particles(platelets,\n                                  L=26, R=3,\n                                  epsilon1=0, epsilon2=0,\n                                  lambda1=1, lambda2=0,\n                                  penaltyFunction=penaltyFunctionGenerator(),\n                                  include.area=FALSE)\ntrajPlatelets <- trajectories(linkedPlatelets)\n\n# Correct trajectory data\nprint(length(trajPlatelets))\n\nfor (i in 1:length(trajPlatelets))\n{\n  newYCoords <- (cellBot - cellTop + 1)  - (trajPlatelets[[i]]$trajectory$yCoord) + ((dim(imgFirst)[2]-capBot)-cellBot+1)\n  print(newYCoords)\n  print(trajPlatelets[[i]]$trajectory$yCoord)\n  trajPlatelets[[i]]$trajectory$yCoord <- newYCoords\n}\n\n#Display frames\nprint(trajPlatelets[[11]])\npaintedTrajectories <- add.contours(raw.frames=capNew,\n                                    binary.frames=preprocessedPlatelets,\n                                    trajectoryset=trajPlatelets,\n                                    mode=\"trajectories\")\n\ninspect.Frames(paintedTrajectories,nframes=7)\n\n#Display trajectories\npng(filename=\"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\TrajectoryData\\\\trajPlot.png\")\nplot2D.TrajectorySet(trajPlatelets, cap)\ndev.off()\ntrajPlotImg = readImage(\"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\TrajectoryData\\\\trajPlot.png\")\ndisplay(trajPlotImg)\n\n#Generate Kinematics Data\nallKinematicFeats.allPlatelets <- kinematics1(trajPlatelets,\n                                              trajectoryIDs=NULL, # will select all trajectory IDs\n                                              acquisitionFrequency=30, # value in milliseconds\n                                              scala=50, # 1 pixel is equivalent to ... micrometer\n                                              feature=NULL) # all kinematic features available\n\nlibrary(xlsx)\ntrajData1 <- list()\nindex <- vector(length = length(trajPlatelets))\nvelocityData1 <- list()\nfor(i in 1:length(trajPlatelets)){\n  vec <- trajPlatelets[[i]]$trajectory$yCoord\n  trajData1[[i]]<- vec\n  index[i] <- length(vec)\n  velocity<- allKinematicFeats.allPlatelets[[i]]$Yvelocity(1:length(trajPlatelets[[i]]$trajectory$yCoord))\n  velocityData1[[i]] <-as.vector(velocity) \n}\ntrajVector <- as.vector(do.call(\"rbind\", lapply(trajData1, as.data.frame)))\nvelocityData <- as.vector(do.call(\"rbind\", lapply(velocityData1, as.data.frame)))\nwrite.csv(trajVector, \"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\TrajectoryData\\\\trajVector.csv\")\nwrite.csv(index, \"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\TrajectoryData\\\\index.csv\")\nwrite.csv(velocityData, \"C:\\\\Users\\\\ayanb_000\\\\Documents\\\\R genecamp\\\\TrajectoryData\\\\velocityData.csv\")\n\n# Display Kinematic Data\nprint(\"Select a trajectory to view data\")\ntrajInput <- as.integer(readline());\nprint(trajInput)\ndev.off()\ndispTrajData <- function(trajSelect,nframes) {\n  par(mfrow=c(2,3))\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Xposition(x),  1, nframes, col = \"green\", lwd = 1.5)\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Xvelocity(x),  1, nframes, col = \"green\", lwd = 1.5)\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Xacceleration(x),  1, nframes, col = \"green\", lwd = 1.5)\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Yposition(x),  1, nframes, col = \"green\", lwd = 1.5)\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Yvelocity(x),  1, nframes, col = \"green\", lwd = 1.5)\n  curve(allKinematicFeats.allPlatelets[[trajSelect]]$Yacceleration(x),  1, nframes, col = \"green\", lwd = 1.5)\n}\n\ndispTrajData(trajInput,length(trajPlatelets[[trajInput]]$trajectory$yCoord))\n# USE traj package to classify\n# also try HMM, SVM\n\n# examples: tweets.df <- do.call(\"rbind\", lapply(tweets, as.data.frame))\n#twListToDF(tweets)\n#library plyr\n#tweets.df = ldply(tweets, function(t) t$toDataFrame())\n",
    "created" : 1452051973748.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "639783276",
    "id" : "5C5963E7",
    "lastKnownWriteTime" : 1444878405,
    "path" : "~/R genecamp/Finished Programs/timeLapseGreen.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}