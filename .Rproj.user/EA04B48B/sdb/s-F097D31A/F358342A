{
    "contents" : "\n#' Thresholds a \\code{Frames} object for green pixels\n#'\n#' Green pixels, or pixels with H value between 61/360 and 140/360 and\n#' S value over 0.15 in the HSV color scheme, are treated as foreground.\n#' All other pixels are treated as background. This is useful in detecting the\n#' Green Flourescence Protein used to denote that a cell is alive.\n#' @param frames A \\code{Frames} object with all 3 color channels(R,G,B)\n#' @return a binary \\code{Frames} object in the green color channel\n#' @examples\n#' library(flowcatchR)\n#' threshedFrames <- greenThresh(MesenteriumSubset)\n#' @export\n#' @author Ayan Bandyopadhyay, Bellarmine College Prep 11/26/2015\n\ngreenThresh <-function(frames)\n{\n  # checks if required packages are loaded\n  if (!requireNamespace(\"flowcatchR\", quietly = TRUE) )\n  {\n    stop(\"flowcatchR needed for this function to work. Please install it.\", call. = FALSE)\n  }\n  threshedFrames = array(dim = c(dim(frames)[1],dim(frames)[2],frameCount))\n\n  for (i in 1:frameCount)\n  {\n    oldGreenImg= c(frames[,,2,i])\n    oldBlueImg = c(frames[,,3,i])\n    oldRedImg =  c(frames[,,1,i])\n    # createGreenImage, createRedImage, and createBlueImage turn gray pixels into background pixels\n    createGreenImage <- function(oldGreen,oldRed,oldBlue)\n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldGreen=0\n      }\n      return(oldGreen)\n    }\n    createRedImage <- function(oldGreen,oldRed,oldBlue)\n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldRed=0\n      }\n      return(oldRed)\n    }\n    createBlueImage <- function(oldGreen,oldRed,oldBlue)\n    {\n      if(oldRed == oldBlue && oldBlue == oldGreen)\n      {\n        oldBlue=0\n      }\n      return(oldBlue)\n    }\n    r <-mapply(createRedImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    g <-mapply(createGreenImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    b <-mapply(createBlueImage,oldGreenFirst,oldRedFirst,oldBlueFirst)\n    r <- matrix(r,nrow = dim(frames)[1], ncol = dim(frames)[2])\n    g <- matrix(g,nrow = dim(frames)[1], ncol = dim(frames)[2])\n    b <- matrix(b,nrow = dim(frames)[1], ncol = dim(frames)[2])\n    r <- c(r)\n    g<- c(g)\n    b <- c(b)\n\n    hsvColors <- rgb2hsv(r=r,g=g,b=b)\n    imgH <- hsvColors[1,]\n    imgS <- hsvColors[2,]\n    imgV <- hsvColors[3,]\n    grayscaleVector <- vector(length=dim(frames)[1]*dim(frames)[2])\n\n    # createBinaryVector creates a pixel of value 1 if hue is green and saturation>0.15\n    createBinaryVector <- function(grayVector,h,s,v)\n    {\n\n      if (h>(61/360) && h<(140/360) && s>0.15)\n      {\n        grayVector = 1\n      }\n      else\n      {\n        grayVector = 0\n      }\n      return(grayVector)\n    }\n\n    grayscaleVector <- mapply(createBinaryVector,grayVector=grayscaleVector,h=imgH,s=imgS,v=imgV)\n\n    # binaryImage holds the thresholded image. Green pixels are white, the rest is black.\n    binaryImage <- matrix(grayscaleVector, ncol = dim(frames)[2],nrow = dim(frames)[1])\n    threshedFrames[,,i] <- binaryImage\n  }\n  rgbFrames = EBImage::channel(as.Image(threshedFrames),'rgb')\n  greenFrames = channel.Frames(rgbFrames, \"green\")\n  return(greenFrames)\n}\n\n\n#' Generate a \\code{TrajectorySet} object with corrected y-values\n#'\n#' Returns a TrajectorySet so that the y value is the distance from the bottom of the\n#' Frames object, not from the top\n#' @param particles A \\code{ParticleSet} object\n#' @param L Maximum number of pixels an object can move in two consecutive frames\n#' @param R Linkrange, i.e. the number of consecutive frames to search for potential candidate\n#' links\n#' @param epsilon1 A numeric value, to be used in the formula.\n#' Jitter for allowing angular displacements\n#' @param epsilon2 A numeric value, to be used in the formula.\n#' Jitter for allowing spatial displacements\n#' @param lambda1 A numeric value. Multiplicative factor for the penalty function\n#' @param lambda2 A numeric value. Multiplicative factor applied to the angular displacement\n#' @param penaltyFunction A function structured in such a way to be applied as penalty function\n#' in the linking\n#' @param verboseOutput Logical, whether the output should report additional intermediate steps.\n#'  For debugging use mainly.\n#' @param prog Logical, whether the a progress bar should be shown during the tracking phase\n#' @param include.intensity Logical, whether to include also intensity change of the particles\n#' in the cost function calculation\n#' @param include.area Logical, whether to include also area change of the particles\n#' in the cost function calculation\n#' @param frames The \\code{Frames} object that the \\code{ParticleSet} object is\n#' derived from\n#' @return A \\code{TrajectorySet} object\n#' @examples\n#' library(flowcatchR)\n#' platelets <-particles(channel.Frames(MesenteriumSubset,\"red\"))\n#' trajSet <- generateTraj(platelets,\n#'                        L=26, R=3,\n#'                        epsilon1=0, epsilon2=0,\n#'                        lambda1=1, lambda2=0,\n#'                        penaltyFunction=penaltyFunctionGenerator(),\n#'                        include.area=FALSE, MesenteriumSubset)\n#' @export\n#' @author Ayan Bandyopadhyay, Bellarmine College Prep 11/26/2015\n\ngenerateTraj <- function (particles,\n                         L=26, R=3,\n                         epsilon1=0, epsilon2=0,\n                         lambda1=1, lambda2=0,\n                         penaltyFunction=penaltyFunctionGenerator(),\n                         include.area=FALSE, frames)\n{\n  linkedParticles <- link.particles(particles,\n                                    L=L, R=R,\n                                    epsilon1=epsilon1, epsilon2=epsilon2,\n                                    lambda1=lambda1, lambda2=lambda2,\n                                    penaltyFunction=penaltyFunction,\n                                    verboseOutput=FALSE, prog=FALSE,\n                                    include.intensity=TRUE,include.area=TRUE)\n  trajParticles <- trajectories(linkedParticles)\n  # Correct trajectory data\n  for (i in 1:length(trajParticles))\n  {\n    newYCoords <- dim(frames)[2]  - (trajParticles[[i]]$trajectory$yCoord)\n    trajParticles[[i]]$trajectory$yCoord <- newYCoords\n  }\n  return(trajParticles)\n}\n\n#' Generates 24 measures for each trajectory\n#'\n#' Removes trajectories with less than 4 data points\n#' @param trajSet This is a \\code{TrajectorySet} object,\n#' @return A matrix 24 columns wide. Each row corresponds to one trajectory.\n#' @examples\n#' library(flowcatchR)\n#' trajPlatelets <- trajectories(particles(channel.Frames(MesenteriumSubset,\"red\")))\n#' trajData <-trajMeasures(trajPlatelets)\n#' @export\n#' @author Ayan Bandyopadhyay, Bellarmine College Prep 11/26/2015\n\ntrajMeasures <- function(trajSet)\n{\n  library(class)\n  library(traj)\n\n  # create 2 vectors: trajVector and index\n  trajData <- list()\n  index <- vector(length = length(trajSet))\n  for(i in 1:length(trajSet))\n  {\n    vec <- trajSet[[i]]$trajectory$yCoord\n    trajData[[i]]<- vec\n    index[i] <- length(vec)\n  }\n  trajVector <- as.vector(do.call(\"rbind\", lapply(trajData, as.data.frame)))\n\n  # create matrix of 24 measurements for each trajectory\n  trajDataMatrix = matrix(ncol = 24, nrow = length(index))\n  for (i in 1:length(index))\n  {\n    if(index[i]<4)\n    {\n      trajVector <- trajVector[-(1:index[i])]\n    }\n    else\n    {\n      newVector <- trajVector[1:index[i]]\n      newFrame <- matrix(nrow=2,ncol=index[[i]],append(newVector,1:index[i]),byrow= TRUE)\n      timeFrame <- matrix(nrow=2,ncol=index[[i]],append(1:index[i],1:index[i]),byrow= TRUE)\n      s1 <- step1measures(newFrame,timeFrame, ID = FALSE)\n      trajData <- as.numeric(s1$measurments[1,])[2:length(as.vector(s1$measurments[1,]))]\n      trajDataMatrix[i,] <- trajData\n\n      if(length(trajVector) > length(1:index[i]))\n      {\n        trajVector <- trajVector[-(1:index[i])]\n      }\n      else\n      {\n        trajVector <- trajVector\n      }\n    }\n  }\n  # get rid of data for trajectories w/ less than 4 data points\n  for(i in 1:length(trajDataMatrix[,1]))\n  {\n    if( is.na((trajDataMatrix[,1])[i]) )\n    {\n      trajDataMatrix <- trajDataMatrix[-i,]\n    }\n    else\n    {\n      trajDataMatrix <- trajDataMatrix\n    }\n  }\n\n  trajDataFrame <- as.data.frame(trajDataMatrix)\n  return(trajDataFrame)\n}\n\n\n#' Generate KNN classifier with LOOCV\n#'\n#' Fits trajectory data into a K-nearest neighbors classifier using\n#' leave one out cross validation.\n#' @param trajDataFrame A data frame with measures for each trajectory. This can be produced by\n#' function trajMeasures\n#' @param labelVector A vector of labels for each trajectory. Its length must be equal\n#' to the number of rows in trajDataFrame\n#' @param kVal The number of neighbors used for classification\n#' @return A vector of classified labels for each trajectory\n#' @examples\n#' data <- as.data.frame(matrix(1:4,nrow = 2,ncol = 2))\n#' labels <- c(\"live\",\"dead\")\n#' classifierKNN_CV<- fitModelKNN_CV(data,labels,3)\n#' @export\n#' @author Ayan Bandyopadhyay, Bellarmine College Prep 11/26/2015\n\n\nfitModelKNN_CV<- function (trajDataFrame, labelVector, kVal)\n{\n  dataFrame<- trajDataFrame\n  dataFrame$cellStatus <-labelVector\n  dataLabels <- dataFrame[,dim(dataLabels)[2]]\n  dataTrain <- dataFrame[,1:(dim(dataLabels)[2]-1)]\n\n  trajDataCV<- knn.cv(train = dataTrain, cl = dataLabels, k=kVal)\n  mp <- sum(trajDataCV != dataLabels)/length(dataLabels)\n  print(\"Misclassification probability: \" + mp)\n\n  return(trajDataCV)\n}\n\n",
    "created" : 1451979863019.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3984523028",
    "id" : "F358342A",
    "lastKnownWriteTime" : 1452220207,
    "path" : "~/R genecamp/CellTrajectoryAnalysis/R/vidProcessing.R",
    "project_path" : "R/vidProcessing.R",
    "properties" : {
        "notebook_format" : "word_document"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}